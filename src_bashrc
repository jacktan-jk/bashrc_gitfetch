#!/bin/bash

add_to_path() {
    local dir="$1"
    [ -z "$dir" ] && return
    case ":$PATH:" in
        *:"$dir":*) ;;
        *)
            if [ -z "$PATH" ]; then
                PATH="$dir"
            else
                PATH="$PATH:$dir"
            fi
            ;;
    esac
}

add_to_pkg_config_path() {
    local dir="$1"
    [ -z "$dir" ] && return
    case ":$PKG_CONFIG_PATH:" in
        *:"$dir":*) ;;
        *)
            if [ -z "$PKG_CONFIG_PATH" ]; then
                PKG_CONFIG_PATH="$dir"
            else
                PKG_CONFIG_PATH="$PKG_CONFIG_PATH:$dir"
            fi
            ;;
    esac
}

add_to_path "/c/msys64/usr/bin"
add_to_pkg_config_path "/c/msys64/mingw64/lib/pkgconfig"
add_to_path "$HOME/AppData/Local/Packages/PythonSoftwareFoundation.Python.3.13_qbz5n2kfra8p0/LocalCache/local-packages/Python313/Scripts"
add_to_path "/c/Program Files/PostgreSQL/17/bin"
add_to_path "/f/.programs/Qt/5.15.2/msvc2019/bin"
add_to_path "/c/Users/junki/.cargo/bin"
add_to_path "/c/Users/junki/AppData/Local/Programs/Microsoft VS Code/bin/"
export PATH
export PKG_CONFIG_PATH
export PROMPT_DIRTRIM=3

# Bold
BRED="\033[1;31m"      # Red
BGREEN="\033[1;32m"    # Green
BYEL="\033[1;33m"      # Yellow
BBLUE="\033[1;34m"     # Blue
BPUR="\033[1;35m"      # Purple
BCYAN="\033[1;36m"     # Cyan

BLUE='\033[36m'
PUR='\033[35m'
YEL='\033[38;5;220m'
RED='\033[0;31m'
GREEN='\033[0;32m'
U_WHITE='\033[4;37m'
NC='\033[0m'

cur_dir=$(pwd)
cd ~
home_dir=$(pwd)
cd "$cur_dir"

tar_dir="${PROJECTS_ROOT:-$home_dir/Desktop/projects}"
mkdir -p "$tar_dir"
df_file="$tar_dir/.disable_fetch"
py_file="$tar_dir/.disable_win_py"

node_path="/c/Program Files/nodejs/node.exe"

if command -v winpty >/dev/null 2>&1; then
    alias node="winpty \"$node_path\""
    alias watch="winpty watch"
    alias top="winpty top"
else
    alias node="\"$node_path\""
fi

alias npm="npm.cmd"
alias npx="npx.cmd"
alias supabase="npx.cmd supabase"
alias mysql="mysql -uroot -p"

alias status="echo \"\" && date -r \"$tar_dir/.status\" && echo "" && cat \"$tar_dir/.status\""
reload() {
    clear
    # shellcheck disable=SC1090
    "$home_dir/.bashrc"
}
running=true
bNewBr=false
bNewCO=false
bUnstg=false
declare -a pids=()
tmp_dir=""

git_fetch_remotes() {
    local -a remotes=()
    mapfile -t remotes < <(git remote 2>/dev/null)
    if [ ${#remotes[@]} -eq 0 ]; then
        return 0
    fi

    declare -A to_fetch=()
    while IFS= read -r remote_name; do
        [ -z "$remote_name" ] && continue
        to_fetch["$remote_name"]=1
    done < <(git for-each-ref --format='%(upstream:remotename)' refs/heads 2>/dev/null)

    if [ ${#to_fetch[@]} -eq 0 ]; then
        local remote
        for remote in "${remotes[@]}"; do
            if [ "$remote" = "origin" ]; then
                to_fetch["origin"]=1
                break
            fi
        done
        if [ ${#to_fetch[@]} -eq 0 ]; then
            to_fetch["${remotes[0]}"]=1
        fi
    fi

    local -a fetch_list=()
    local remote
    for remote in "${!to_fetch[@]}"; do
        fetch_list+=("$remote")
    done
    IFS=$'\n' fetch_list=($(printf '%s\n' "${fetch_list[@]}" | sort))
    unset IFS

    for remote in "${fetch_list[@]}"; do
        git fetch --no-progress --prune "$remote" > /dev/null 2>&1 || return 1
    done

    return 0
}

cleanup() {
    if ! $running; then
        return
    fi
    
    running=false
    echo -e "\nCancelling fetch..."
    if [ ${#pids[@]} -gt 0 ]; then
        for job in "${pids[@]}"; do
            if kill -0 "$job" 2>/dev/null; then
                kill "$job" 2>/dev/null
            fi
        done
        wait "${pids[@]}" 2>/dev/null
        pids=()
    fi
    [ -d "$tmp_dir" ] && rm -rf "$tmp_dir" 2>/dev/null
    cd "$home_dir"
}

git() {
  if [ "$1" = log ]; then
    shift
    command git log --graph "$@"
  else
    command git "$@"
  fi
}

git_chk_newBR(){
    [ "$running" != true ] && return

    local -a local_branches=()
    mapfile -t local_branches < <(git for-each-ref --format='%(refname:short)' refs/heads 2>/dev/null)

    declare -A local_map=()
    local branch
    for branch in "${local_branches[@]}"; do
        local_map["$branch"]=1
    done

    local -a remote_branches=()
    mapfile -t remote_branches < <(git for-each-ref --format='%(refname:strip=2)' 'refs/remotes/*' 2>/dev/null)

    local -a new_branches=()
    local remote_entry remote_branch
    for remote_entry in "${remote_branches[@]}"; do
        [ -z "$remote_entry" ] && continue
        [[ $remote_entry == */HEAD ]] && continue
        remote_branch=${remote_entry#*/}
        if [ -z "${local_map[$remote_branch]}" ]; then
            new_branches+=("$remote_entry")
        fi
    done

    [ "${#new_branches[@]}" -lt 1 ] && return

    local header prefix last_prefix i rb_item
    if [ "$bNewCO" = false ] && [ "$bUnstg" = false ]; then
        header="└──"
        prefix=$'\t├──'
        last_prefix=$'\t└──'
    else
        header="├──"
        prefix=$'│\t├──'
        last_prefix=$'│\t└──'
    fi

    echo -e "│"
    echo -e "$header ${BLUE}[ BRANCHES ]${NC}"
    for i in "${!new_branches[@]}"; do
        rb_item="${new_branches[$i]}"
        if [ "$i" -eq $(( ${#new_branches[@]} - 1 )) ]; then
            echo -e "$last_prefix \"$rb_item\""
        else
            echo -e "$prefix \"$rb_item\""
        fi
    done

    if [ "$bNewCO" = false ] && [ "$bUnstg" = false ]; then
        echo ""
    fi
}

git_chk_branches() {
    [ "$running" != true ] && return

    local current_branch
    current_branch=$(git symbolic-ref --short HEAD 2>/dev/null)

    local STASH
    STASH=$(git rev-list --walk-reflogs --ignore-missing --count refs/stash 2>/dev/null)

    declare -A remote_branch_lookup=()
    local remote_ref branch_name
    while IFS= read -r remote_ref; do
        [ -z "$remote_ref" ] && continue
        [[ $remote_ref == */HEAD ]] && continue
        branch_name=${remote_ref#*/}
        remote_branch_lookup["$branch_name"]=1
    done < <(git for-each-ref --format='%(refname:strip=2)' 'refs/remotes/*' 2>/dev/null)

    local -a updates=()
    while IFS=$'\t' read -r branch upstream track; do
        [ -z "$branch" ] && continue
        if [ -z "$upstream" ]; then
            if [ -n "${remote_branch_lookup[$branch]}" ]; then
                updates+=("'$branch' [ ${YEL}no upstream configured${NC} ]")
            fi
            continue
        fi

        local ahead=0 behind=0
        if [[ $track =~ ahead[[:space:]]+([0-9]+) ]]; then
            ahead=${BASH_REMATCH[1]}
        fi
        if [[ $track =~ behind[[:space:]]+([0-9]+) ]]; then
            behind=${BASH_REMATCH[1]}
        fi

        if [ "$behind" -gt 0 ] || [ "$ahead" -gt 0 ]; then
            local status="[ "
            if [ "$behind" -gt 0 ]; then
                status+="${RED}▼$behind${NC}"
            fi
            if [ "$behind" -gt 0 ] && [ "$ahead" -gt 0 ]; then
                status+=" "
            fi
            if [ "$ahead" -gt 0 ]; then
                status+="${GREEN}▲$ahead${NC}"
            fi
            status+=" ]"
            updates+=("'$branch' $status")
        fi
    done < <(git for-each-ref --format='%(refname:short)%09%(upstream:short)%09%(upstream:track)' refs/heads 2>/dev/null)

    local -a status_lines=()
    mapfile -t status_lines < <(git status --porcelain 2>/dev/null)

    local tracked_total=0 added=0 deleted=0 modified=0 renamed=0 untracked=0
    declare -A tracked_seen=()
    local entry x y path
    for entry in "${status_lines[@]}"; do
        [ -z "$entry" ] && continue
        x=${entry:0:1}
        y=${entry:1:1}
        path=${entry:3}

        if [ "$x$y" = "??" ]; then
            ((untracked++))
            continue
        fi

        if [[ $path == *" -> "* ]]; then
            path=${path##* -> }
        fi

        if [ -z "${tracked_seen[$path]}" ]; then
            tracked_seen["$path"]=1
            ((tracked_total++))
        fi

        if [ "$x" = "A" ] || [ "$y" = "A" ]; then
            ((added++))
        fi
        if [ "$x" = "D" ] || [ "$y" = "D" ]; then
            ((deleted++))
        fi
        if [ "$x" = "R" ] || [ "$y" = "R" ]; then
            ((renamed++))
        fi
        if [ "$x" = "M" ] || [ "$y" = "M" ] || [ "$x" = "C" ] || [ "$y" = "C" ] || [ "$x" = "U" ] || [ "$y" = "U" ]; then
            ((modified++))
        fi
    done

    local total_changed=$((tracked_total + untracked))
    local -a unstaged=()
    if [ "$total_changed" -gt 0 ] && [ -n "$current_branch" ]; then
        local message="→ ${total_changed} file"
        [ "$total_changed" -ne 1 ] && message+="s"
        message+=" changed"

        local -a details=()
        if [ "$added" -gt 0 ]; then
            details+=("${GREEN}+${added}${NC} new")
        fi
        if [ "$modified" -gt 0 ]; then
            details+=("${GREEN}${modified}${NC} modified")
        fi
        if [ "$deleted" -gt 0 ]; then
            details+=("${RED}-${deleted}${NC} deleted")
        fi
        if [ "$renamed" -gt 0 ]; then
            details+=("$renamed renamed")
        fi
        if [ "$untracked" -gt 0 ]; then
            details+=("$untracked untracked")
        fi

        if [ ${#details[@]} -gt 0 ]; then
            message+=" ("
            local idx
            for idx in "${!details[@]}"; do
                [ "$idx" -gt 0 ] && message+=", "
                message+="${details[$idx]}"
            done
            message+=")"
        fi

        unstaged+=("'$current_branch' ${message}")
    fi

    local header prefix last_prefix i
    if [ "${#unstaged[@]}" -lt 1 ]; then
        header="└──"
        prefix=$'\t├──'
        last_prefix=$'\t└──'
    else
        header="├──"
        prefix=$'│\t├──'
        last_prefix=$'│\t└──'
    fi

    if [ "${#updates[@]}" -gt 0 ]; then
        bNewCO=true
        echo -e "│"
        echo -e "$header ${PUR}[ COMMITS ]${NC}"
        for i in "${!updates[@]}"; do
            if [ "$i" -eq $(( ${#updates[@]} - 1 )) ]; then
                echo -e "$last_prefix ${updates[$i]}"
            else
                echo -e "$prefix ${updates[$i]}"
            fi
        done
        [ "${#unstaged[@]}" -lt 1 ] && echo ""
    fi

    if [ "${#unstaged[@]}" -gt 0 ]; then
        bUnstg=true
        echo -e "│"
        echo -e "└── ${RED}[ UNSTAGED ]${NC}"
        for i in "${!unstaged[@]}"; do
            if [ "$i" -eq $(( ${#unstaged[@]} - 1 )) ]; then
                echo -e "\t└── ${unstaged[$i]}"
            else
                echo -e "\t├── ${unstaged[$i]}"
            fi
        done
        echo ""
    fi

    if [ "$STASH" -gt 0 ]; then
        echo -e "* ${STASH} stash found.\n"
    fi
}

############################################################################################################
# Check which python to use (WIN, MINGW)
############################################################################################################
if [ ! -f "$py_file" ] && { [ "$cur_dir" = "$home_dir" ] || [ "$cur_dir" = "$tar_dir" ]; }; then
    echo "0" > "$py_file"
    if command -v attrib >/dev/null 2>&1; then
        attrib +h "$py_file" 2>/dev/null
    fi
fi

if [[ "$OSTYPE" == "linux-gnu"* || "$OSTYPE" == "darwin"* ]]; then
        py_type="LINUX"
else
    if [ "$(cat "$py_file")" -eq "0" ]; then
        export PATH="/c/Users/junki/AppData/Local/Microsoft/WindowsApps:$PATH"
        alias python='winpty python.exe'
        py_type="WINDOWS"
    else
        export PATH=$(echo $PATH | tr ':' '\n' | grep -v '/c/msys64/ucrt64/bin' | paste -sd:)
        export PATH="/c/msys64/mingw64/bin:/c/msys64/mingw64/lib:$PATH"
        if alias python >/dev/null 2>&1; then
            unalias python
        fi
        py_type="MINGW64"
    fi
fi

hash -r
sync

############################################################################################################
# Check directory
############################################################################################################
if [ "$cur_dir" = "$home_dir" ] || [ "$cur_dir" = "$tar_dir" ]; then
    cd "$tar_dir"
elif [[ "${BASH_SOURCE[0]}" != "$0" ]]; then
    return
fi

############################################################################################################
# Check if fetching is disabled
############################################################################################################
if [ ! -f "$df_file" ] && { [ "$cur_dir" = "$home_dir" ] || [ "$cur_dir" = "$tar_dir" ]; }; then
    echo "0" > "$df_file"
    if command -v attrib >/dev/null 2>&1; then
        attrib +h "$df_file" 2>/dev/null
    fi
fi

if [ -f "$df_file" ] && [ "$(cat "$df_file")" -eq "1" ]; then
    return
fi

ping_flag="-n 1 -w 100"

if [[ "$OSTYPE" == "linux-gnu"* || "$OSTYPE" == "darwin"* ]]; then
    ping_flag="-c 1 -W 0.1"
fi

if ! ping $ping_flag 1.1.1.1 &> /dev/null; then
    echo -e "${BLUE}[INTERNET]${NC} ${RED}Unavailable${NC}"
    echo -e "${PUR}[PYTHON]${NC}   ${U_WHITE}$py_type${NC}"
    cleanup
    if [[ "${BASH_SOURCE[0]}" != "$0" ]]; then
        return
    else
        exit 0
    fi
fi

############################################################################################################
# Start of console printouts and main feaatures
############################################################################################################

echo -e "${YEL}[TIP]${NC} To change python type, \"echo (0: WIN, 1: MINGW) > .disable_win_py\", restart"
echo -e "${YEL}[TIP]${NC} To disable fetch, \"echo 1 > .disable_fetch\""
echo -e "${YEL}[TIP]${NC} To cancel fetch, \"ctrl-C\"\n"

echo -e "${BLUE}[INTERNET]${NC} ${GREEN}OK${NC}"
echo -e "${PUR}[PYTHON]${NC}   ${U_WHITE}$py_type${NC}\n"

trap cleanup SIGINT SIGTERM

cols=$(tput cols)
total_repo=0
pass_repo=0
declare -a repo_list
declare -a repo_dirs
declare -a fetch_pids
declare -A repo_logs
declare -A repo_success
declare -A repo_errors

start_time=$(date +%s)
for dir in "$tar_dir"/*; do
    [ "$running" != true ] && [ "${BASH_SOURCE[0]}" != "$0" ] && return
    [ ! -d "$dir/.git" ] && continue

    repo_name=$(basename "$dir")
    echo "Fetching: $repo_name..."
    ((total_repo++))
    repo_list+=("$repo_name")
    repo_dirs+=("$dir")
    (
        cd "$dir" || exit 1
        git_fetch_remotes
    ) &
    fetch_pids+=($!)
done

if [ $total_repo -eq 0 ]; then
    echo -e "${BLUE}* no previous fetch status.${NC}" > "$tar_dir/.status"
    if [ "${BASH_SOURCE[0]}" != "$0" ]; then
        return
    else
        exit
    fi
fi

# Wait for all fetches.
for i in "${!fetch_pids[@]}"; do
    pid=${fetch_pids[$i]}
    repo=${repo_list[$i]}
    if wait "$pid"; then
        repo_success["$repo"]=1
        ((pass_repo++))
    else
        repo_success["$repo"]=0
        repo_errors["$repo"]="${RED}[ERROR] Failed to fetch repo: $repo! Ensure access!${NC}\n"
    fi
done

# Gather branch information for successfully fetched repos.
for i in "${!repo_dirs[@]}"; do
    repo=${repo_list[$i]}
    dir=${repo_dirs[$i]}
    [ "${repo_success[$repo]}" != 1 ] && continue
    repo_logs["$repo"]=$( \
        cd "$dir" || exit 0
        bNewCO=false
        bUnstg=false
        branch_output=$(git_chk_branches)
        new_branch_output=$(git_chk_newBR)
        printf '%s%s' "$new_branch_output" "$branch_output"
    )
done

end_time=$(date +%s)
elapsed=$(($end_time - $start_time))
elapsed_sec=$elapsed
echo ""
if [ "$running" == true ]; then
    # Group branch info by repo.
    : > "$tar_dir/.status"
    for repo in "${repo_list[@]}"; do
        local_output="${repo_logs[$repo]}"
        local_error="${repo_errors[$repo]}"
        if [ -n "$local_output" ] || [ -n "$local_error" ]; then
            {
                echo -e "${YEL}[ $repo ]${NC}"
                if [ -n "$local_error" ]; then
                    echo -e "$local_error"
                fi
                if [ -n "$local_output" ]; then
                    printf "%s" "$local_output"
                fi
                printf "%0.s─" $(seq 1 $cols)
                echo -e "\n"
            } >> "$tar_dir/.status"
        fi
    done

    cat "$tar_dir/.status"

    if [ "$total_repo" -eq "$pass_repo" ]; then
        echo -e "${GREEN}[SUCCESS]${NC} Fetched ${total_repo} repositories in ${elapsed_sec}s"
    else
        echo -e "${RED}[FAILED]${NC} Fetched ${pass_repo} of ${total_repo} repositories in ${elapsed_sec}s"
    fi
fi

running=false
