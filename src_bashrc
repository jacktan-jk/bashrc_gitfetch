#!/bin/bash
export PATH=$PATH:"/c/msys64/usr/bin"
export PKG_CONFIG_PATH=/c/msys64/mingw64/lib/pkgconfig:$PKG_CONFIG_PATH
export PATH=$PATH:"~/AppData/Local/Packages/PythonSoftwareFoundation.Python.3.13_qbz5n2kfra8p0/LocalCache/local-packages/Python313/Scripts"
export PATH=$PATH:"/c/Program Files/PostgreSQL/17/bin"
export PATH=$PATH:"/f/.programs/Qt/5.15.2/msvc2019/bin"
export PATH=$PATH:"/c/Users/junki/.cargo/bin"
export PATH=$PATH:"/c/Users/junki/AppData/Local/Programs/Microsoft VS Code/bin/"
export PROMPT_DIRTRIM=3
PGPASSWORD=postgres

# Bold
BRED="\033[1;31m"      # Red
BGREEN="\033[1;32m"    # Green
BYEL="\033[1;33m"      # Yellow
BBLUE="\033[1;34m"     # Blue
BPUR="\033[1;35m"      # Purple
BCYAN="\033[1;36m"     # Cyan

BLUE='\033[36m'
PUR='\033[35m'
YEL='\033[38;5;220m'
RED='\033[0;31m'
GREEN='\033[0;32m'
U_WHITE='\033[4;37m'
NC='\033[0m'

cur_dir=$(pwd)
cd ~
home_dir=$(pwd)
cd "$cur_dir"

tar_dir="$home_dir/Desktop/projects"
df_file=".disable_fetch"
py_file="$tar_dir/.disable_win_py"

node_path="/c/Program\ Files/nodejs/node.exe"
npm_path="/c/Program\ Files/nodejs/npm"

alias node="winpty ${node_path}"
alias npm="npm.cmd"
alias npx="npx.cmd"
alias supabase="npx.cmd supabase"
alias watch="winpty watch"
alias mysql="mysql -uroot -p"

alias status="echo "" && date -r $tar_dir/.status && cat $tar_dir/.status"
alias reload="clear && $home_dir/.bashrc"
alias top="winpty top"

running=true
bNewBr=false
bNewCO=false
bUnstg=false

cleanup() {
    if ! $running; then
        return
    fi
    
    running=false
    echo -e "\nCancelling fetch..."
    for job in $(jobs -p); do
        disown "$job" 2>/dev/null
    done
    kill 0 2>/dev/null
    [ -d "$tmp_dir" ] && rm -rf "$tmp_dir" 2>/dev/null
    cd "$home_dir"
}

git() {
  if [ "$1" = log ]; then
    shift
    command git log --graph "$@"
  else
    command git "$@"
  fi
}

git_chk_newBR(){
    [ "$running" != true ] && return

    # Load branch lists into arrays
    local local_branches=() remote_branches=() new_branches=()
    readarray -t local_branches < <(git branch --format="%(refname:short)" 2>/dev/null)
    readarray -t remote_branches < <(git branch -r --format="%(refname:lstrip=3)" 2>/dev/null | grep -vE 'HEAD')

    # Build a lookup table for local branches.
    declare -A local_map
    for branch in "${local_branches[@]}"; do
         local_map["$branch"]=1
    done

    # Iterate remote branches and add those not in the lookup.
    for rb in "${remote_branches[@]}"; do
         if [[ ${local_map[$rb]:-0} -eq 1 ]]; then
              continue
         fi
         new_branches+=("$rb")
    done

    # Print header if there are any new branches.
    [ "${#new_branches[@]}" -lt 1 ] && return

    local header prefix last_prefix i rb_item
    if [ "$bNewCO" = false ] && [ "$bUnstg" = false ]; then
         header="└──"
         prefix="\t├──"
         last_prefix="\t└──"
    else
         header="├──"
         prefix="│\t├──"
         last_prefix="│\t└──"
    fi
    echo -e "│"
    echo -e "$header ${BLUE}[ BRANCHES ]${NC}"
    for i in "${!new_branches[@]}"; do
         rb_item="${new_branches[$i]}"
         if [ "$i" -eq "$(( ${#new_branches[@]} - 1 ))" ]; then
             echo -e "$last_prefix \"$rb_item\""
         else
             echo -e "$prefix \"$rb_item\""
         fi
    done

    if [ "$bNewCO" = false ] && [ "$bUnstg" = false ]; then
         echo ""
    fi
}

git_chk_branches() {
    [ "$running" != true ] && return

    local updates=() unstaged=() current_branch
    current_branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)

    local STASH
    STASH=$(git rev-list --walk-reflogs --ignore-missing --count refs/stash 2>/dev/null)

    local branches=()
    readarray -t branches < <(git branch --format="%(refname:short)" 2>/dev/null)

    # Create temporary directory for parallel results.
    local tmp_dir
    tmp_dir=$(mktemp -d)

    local pids=()
    for branch in "${branches[@]}"; do
        (
            local branch_out="" UPSTREAM BEHIND AHEAD diffstat formatted_diff
            # Get upstream; if not set, try to set it.
            UPSTREAM=$(git rev-parse --abbrev-ref "$branch@{upstream}" 2>/dev/null || echo "")
            if [ -z "$UPSTREAM" ]; then
                if ! git show-ref --verify --quiet "refs/remotes/origin/$branch"; then
                    exit 0
                fi
                git branch --set-upstream-to="origin/$branch" "$branch" >/dev/null 2>&1
                UPSTREAM="origin/$branch"
            fi

            BEHIND=$(git rev-list --count "$branch..$UPSTREAM" 2>/dev/null || echo 0)
            AHEAD=$(git rev-list --count "$UPSTREAM..$branch" 2>/dev/null || echo 0)

            # For the current branch, check for unstaged changes.
            if [ "$branch" = "$current_branch" ]; then
                diffstat=$(git diff HEAD --shortstat 2>/dev/null)
                if [ -n "$diffstat" ]; then
                    if echo "$diffstat" | grep -q "changed"; then
                        formatted_diff=$(echo "$diffstat" | sed -E \
                            -e 's/([0-9]+) file(s)? changed/\1 file\2,/' \
                            -e 's/, ([0-9]+) (insertion|addition)s?\(\+\)/ +\1/' \
                            -e 's/, ([0-9]+) (deletion|deletions?)\(-\)/ -\1/')
                    else
                        formatted_diff="$diffstat"
                    fi
                    formatted_diff=$(echo "$formatted_diff" | sed -E "s/\+([0-9]+)/$(printf '%b' "$GREEN")+\1$(printf '%b' "$NC")/g")
                    formatted_diff=$(echo "$formatted_diff" | sed -E "s/ -([0-9]+)/ $(printf '%b' "$RED")-\1$(printf '%b' "$NC")/g")
                    echo "unstaged:'$branch' →$formatted_diff" >> "$tmp_dir/results.txt"
                fi
            fi

            # Skip if no commit differences.
            if [ "$BEHIND" -lt 1 ] && [ "$AHEAD" -lt 1 ]; then
                exit 0
            fi

            if [ "$BEHIND" -gt 0 ] && [ "$AHEAD" -gt 0 ]; then
                echo "updates:'$branch' [ ${RED}▼$BEHIND${NC} ${GREEN}▲$AHEAD${NC} ]" >> "$tmp_dir/results.txt"
            elif [ "$BEHIND" -gt 0 ]; then
                echo "updates:'$branch' [ ${RED}▼$BEHIND${NC} ]" >> "$tmp_dir/results.txt"
            elif [ "$AHEAD" -gt 0 ]; then
                echo "updates:'$branch' [ ${GREEN}▲$AHEAD${NC} ]" >> "$tmp_dir/results.txt"
            fi
        ) &
        pids+=($!)
    done

    for pid in "${pids[@]}"; do
        wait "$pid"
    done

    # Gather results.
    if [ -f "$tmp_dir/results.txt" ]; then
        while IFS= read -r line; do
            local type=${line%%:*}
            local entry=${line#*:}
            if [ "$type" = "updates" ]; then
                updates+=("$entry")
            elif [ "$type" = "unstaged" ]; then
                unstaged+=("$entry")
            fi
        done < "$tmp_dir/results.txt"
        rm -rf "$tmp_dir"
    fi

    local header prefix last_prefix i
    if [ "${#unstaged[@]}" -lt 1 ]; then
        header="└──"
        prefix="\t├──"
        last_prefix="\t└──"
    else
        header="├──"
        prefix="│\t├──"
        last_prefix="│\t└──"
    fi

    if [ "${#updates[@]}" -gt 0 ]; then
        bNewCO=true
        echo -e "│"
        echo -e "$header ${PUR}[ COMMITS ]${NC}"
        for i in "${!updates[@]}"; do
            if [ "$i" -eq "$(( ${#updates[@]} - 1 ))" ]; then
                echo -e "$last_prefix ${updates[$i]}"
            else
                echo -e "$prefix ${updates[$i]}"
            fi
        done
        [ "${#unstaged[@]}" -lt 1 ] && echo ""
    fi

    if [ "${#unstaged[@]}" -gt 0 ]; then
        bUnstg=true
        echo -e "│"
        echo -e "└── ${RED}[ UNSTAGED ]${NC}"
        for i in "${!unstaged[@]}"; do
            if [ "$i" -eq "$(( ${#unstaged[@]} - 1 ))" ]; then
                echo -e "\t└── ${unstaged[$i]}"
            else
                echo -e "\t├── ${unstaged[$i]}"
            fi
        done
        echo ""
    fi

    if [ "$STASH" -gt 0 ]; then
        echo -e "* ${STASH} stash found.\n"
    fi
}

############################################################################################################
# Check which python to use (WIN, MINGW)
############################################################################################################
if [ ! -f "$py_file" ] && { [ "$cur_dir" = "$home_dir" ] || [ "$cur_dir" = "$tar_dir" ]; }; then
    echo "0" > "$py_file"
    attrib +h "$py_file" 2>/dev/null
fi

if [[ "$OSTYPE" == "linux-gnu"* || "$OSTYPE" == "darwin"* ]]; then
        py_type="LINUX"
else
    if [ "$(cat "$py_file")" -eq "0" ]; then
        export PATH="/c/Users/junki/AppData/Local/Microsoft/WindowsApps:$PATH"
        alias python='winpty python.exe'
        py_type="WINDOWS"
    else
        export PATH=$(echo $PATH | tr ':' '\n' | grep -v '/c/msys64/ucrt64/bin' | paste -sd:)
        export PATH="/c/msys64/mingw64/bin:/c/msys64/mingw64/lib:$PATH"
        if alias python >/dev/null 2>&1; then
            unalias python
        fi
        py_type="MINGW64"
    fi
fi

hash -r
sync

############################################################################################################
# Check directory
############################################################################################################
if [ "$cur_dir" = "$home_dir" ] || [ "$cur_dir" = "$tar_dir" ]; then
    cd "$tar_dir"
elif [[ "${BASH_SOURCE[0]}" != "$0" ]]; then
    return
fi

############################################################################################################
# Check if fetching is disabled
############################################################################################################
if [ ! -f "$df_file" ] && { [ "$cur_dir" = "$home_dir" ] || [ "$cur_dir" = "$tar_dir" ]; }; then
    echo "0" > "$df_file"
    attrib +h "$df_file" 2>/dev/null
fi

if [ -f "$df_file" ] && [ "$(cat "$df_file")" -eq "1" ]; then
    return
fi

ping_flag="-n 1 -w 100"

if [[ "$OSTYPE" == "linux-gnu"* || "$OSTYPE" == "darwin"* ]]; then
    ping_flag="-c 1 -W 0.1"
fi

if ! ping $ping_flag 1.1.1.1 &> /dev/null; then
    echo -e "${BLUE}[INTERNET]${NC} ${RED}Unavailable${NC}"
    echo -e "${PUR}[PYTHON]${NC}   ${U_WHITE}$py_type${NC}"
    cleanup
    if [[ "${BASH_SOURCE[0]}" != "$0" ]]; then
        return
    else
        exit 0
    fi
fi

############################################################################################################
# Start of console printouts and main feaatures
############################################################################################################

echo -e "${YEL}[TIP]${NC} To change python type, \"echo (0: WIN, 1: MINGW) > .disable_win_py\", restart"
echo -e "${YEL}[TIP]${NC} To disable fetch, \"echo 1 > .disable_fetch\""
echo -e "${YEL}[TIP]${NC} To cancel fetch, \"ctrl-C\"\n"

echo -e "${BLUE}[INTERNET]${NC} ${GREEN}OK${NC}"
echo -e "${PUR}[PYTHON]${NC}   ${U_WHITE}$py_type${NC}\n"

trap cleanup SIGINT SIGTERM

cols=$(tput cols)
total_repo=0
pass_repo=0
declare -a pids
declare -a repo_list
tmp_dir=$(mktemp -d)

start_time=$(date +%s%3N)
for dir in "$tar_dir"/*; do
    [ "$running" != true ] && [ "${BASH_SOURCE[0]}" != "$0" ] && return
    [ ! -d "$dir/.git" ] && continue
    
    repo_name=$(basename "$dir")
    echo "Fetching: $repo_name..."
    ((total_repo++))
    repo_list+=("$repo_name")
    (
        cd "$dir" || return
        git -C "$dir" fetch --no-progress --all --prune > /dev/null 2>&1

        if [ $? -ne 0 ] && [ -d "$tmp_dir" ]; then
            echo -e "${RED}[ERROR] Failed to fetch repo: $repo_name! Ensure access!${NC}\n" > "$tmp_dir/$repo_name.log"
            exit 1
        fi

        tmp_branch=$(mktemp)
        tmp_new=$(mktemp)

        git_chk_branches > "$tmp_branch" 2>&1
        git_chk_newBR > "$tmp_new" 2>&1

        if [ -d "$tmp_dir" ]; then
            cat "$tmp_new" "$tmp_branch" > "$tmp_dir/$repo_name.log"
            rm -f "$tmp_branch" "$tmp_new" "$repo_name.log" > /dev/null 2>&1
        fi
    ) &
    pids+=($!)
done

if [ $total_repo -eq 0 ]; then
    echo -e "${BLUE}* no previous fetch status.${NC}" > $tar_dir/.status
    if [ "${BASH_SOURCE[0]}" != "$0" ]; then
        return
    else
        exit
    fi
fi

# Wait for all fetches.
for pid in "${pids[@]}"; do
    wait "$pid"
    [ $? -eq 0 ] && ((pass_repo++))
done

end_time=$(date +%s%3N)
elapsed=$(($end_time - $start_time))
elapsed_sec=$(awk "BEGIN {printf \"%.1f\", $elapsed/1000}")

if [ "$running" == true ]; then 
    # Group branch info by repo.
    echo "" > $tar_dir/.status
    for repo in "${repo_list[@]}"; do
        if [ -s "$tmp_dir/$repo.log" ]; then
            echo -e "${YEL}[ $repo ]${NC}" >> $tar_dir/.status
            cat "$tmp_dir/$repo.log" >> $tar_dir/.status
            printf "%0.s─" $(seq 1 $cols) >> $tar_dir/.status
            echo -e "\n" >> $tar_dir/.status
        fi
    done
    
    cat $tar_dir/.status

    if [ "$total_repo" -eq "$pass_repo" ]; then
        echo -e "${GREEN}[SUCCESS]${NC} Fetched ${total_repo} repositories in ${elapsed_sec}s"
    else
        echo -e "${RED}[FAILED]${NC} Fetched ${pass_repo} of ${total_repo} repositories in ${elapsed_sec}s"
    fi
fi

[ -d "$tmp_dir" ] && rm -rf "$tmp_dir" 2>/dev/null
running=false
